## this指向

### 1. 为什么要有this

- 在常见的编程语言中，几乎都有this这个关键字（Objective-C中使用的是self），但是JavaScript中的this和常见的面向对象语言中的this不太一样：
  - 常见面向对象的编程语言中，比如Java、C++、Swift、Dart等等一系列语言中，this通常只会出现在类的方法中。
  - 也就是你需要有一个类，类中的方法（特别是实例方法）中，this代表的是当前调用对象。
  - 但是JavaScript中的this更加灵活，无论是它出现的位置还是它代表的含义。

### 2. this的绑定规则

- this的绑定和定义的位置（编写的位置）没有关系；

- this的绑定和调用方式以及调用的位置有关系；
- 绑定一：默认绑定；
  - 独立的函数调用，我们可以理解成函数没有被绑定到某个对象上进行调用；（this指向window）
- 绑定二：隐式绑定；
  - 也就是它的调用位置中，是通过某个对象发起的函数调用(谁调用this指向谁)

- 绑定三：显示绑定；
  - 必须在调用的对象内部有一个对函数的引用（比如一个属性）；
  - 如果没有这样的引用，在进行调用时，会报找不到该函数的错误；
  - 正是通过这个引用，间接的将this绑定到了这个对象上

- 绑定四：new关键字
  -  指向实例话对象（除非构造函数返回一个引用类型，则new失效。this指针绑定变为返回的引用类型）
  - new都干了些什么？      
    -  创建一个空对象；
    - 将空对象的原型，指向于构造函数的原型；
    - 将空对象作为构造函数的上下文（改变this指向）；
    - 对有返回值的构造函数做判断处理

- 绑定五：箭头函数的绑定
  - 箭头函数就比较特殊了，他没有明确的指向，他里面的 this 其实是根据他的上级来定的，也就是他的 this 指向等于他的上级。

### 3. 优先级

- 箭头函数 > new > bind > apply > call > obj > 直接调用

```text
在 js 中 this 不是固定不变的，它会随着执行环境的改变而改变。
要注意的是 this 取什么值，是在执行时确认的，定义时无法确认。
```

### 4. this 调用几种场景

- 浏览器里，在全局范围内的 this 指向 window 对象； 
- 在函数中，this 永远指向最后调用他的那个对象；
- 构造函数中，this 指向 new 出来的那个新的对象；
- 箭头函数中 this 比较特殊,箭头函数 this 为父作用域的 this，不是调用时的 this.
- 这四种方式，都是调用时确定的，也就是动态的，而箭头函数的this指向是静态的,声明的时候就确定了下来；

### 5. 改变this的方法

```text
apply 、 call 、 bind 都可以改变this的指向；
三者都可以改变函数的 this 对象指向
三者第⼀个参数都是 this 要指向的对象，如果没有这个参数或参数为 undefined、 null ，则默认指向全局 window
三者都可以传参，但是 apply 是数组形式传递，⽽ call 是以散落的方式传递，且 apply 和 call 是⼀次性传⼊参数，⽽ bind 可以分为多次传⼊
bind 是返回绑定 this 之后的函数， apply 、 call 则是⽴即执⾏，bind需要调用；
```

### 6. 箭头函数中的this的指向

-  箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象)，此处指父级作用域，而不是执行时的对象 

-  箭头函数中，this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。 

  ```js
  var name = "我在window里面";
  var obj1 = {
      name : "我是obj1里面的",
      fn(){
          console.log(this);//obj1
          var that = this;
          console.log(that);
          setTimeout(() => {  //箭头函数的this指向继承自父级执行上下文中的this 在声明的时候就已经确定了
              console.log(this.name); //  我是obj1里面的
              console.log(that.name); //  我是obj1里面的
          },1000);
      }
  }
  obj1.fn();
  
  var name = "我在window里面";
  var obj1 = {
      name : "我是obj1里面的",
      fn : () => { //父级也是箭头函数 那么它的this指向为（obj1对象执行上下文中的this）window
          console.log(this);//window
          var that = this;
          console.log(that);
          setTimeout(() => {  //箭头函数的this指向继承自父级执行上下文中的this 在声明的时候就已经确定了
              console.log(this.name); //  我是window里面的
              console.log(that.name); //  我是window里面的
          },1
                     000);
      }
  }
  obj1.fn();
  ```

### 7. 定时器里面的this指向

-  在使定时器setTimeout和setInterval时，会遇到this的指向问题，在没有特殊的指向情况下，两个定时器的回调函数中的this的指向都是window,因为js里的定时器方法定义在window下的。 

-  为了解决这个问题，通常在函数的外部存一个变量，在回调函数中使用这个变量，在就是使用[箭头函数](https://so.csdn.net/so/search?q=箭头函数&spm=1001.2101.3001.7020)，因为箭头函数本身没有this,他的this继承的是自身所在作用域。 

  ```js
  setTimeout(f1,100);  //window
  setTimeout(obj.print,100);   //window
  
  setTimeout(obj.print(),100);   // 定时器里面的参数1是obj.print()的返回值undefined 和定时器的this指向没有任何关系 
  //只是把obj.print()调用了一遍 相当于 打印的this 也是 指向 obj
  var res = obj.print();  //this 指向 obj
  setTimeout(res,100);
  
  var name = "我在window里面";
  var obj1 = {
      name : "我是obj1里面的",
      fn(){
          console.log(this);
          var that = this;
          console.log(that);
          setTimeout(function(){
              console.log(this.name); //  我是window里面的
              console.log(that.name); //  我是obj1里面的
          },1000)
      }
  }
  obj1.fn(); //this 指向 obj //{name: "我是obj1里面的", fn: ƒ}
  //"我在window里面" "我是obj1里面的" 定时器里面打印内容 定时器里面的this在普通函数中一定指向window
  ```

### 8. 对象里面调用函数的this指向

- 普通函数的this

  -  普通函数的this : this就是谁调用 this就指向谁 this是在调用的时候确定的 

    ```js
    function f1(){
    	console.log(this);
    }
    f1(); //window
    ```

- 对象里面的方法this

  -  对象里面的方法, 它里面的this指向当前这个对象 

    ```js
    var obj = {
        a : 6,
        b : 7,
        name : "zhangshang",
        print(){
            // console.log(this.a + this.b);
            console.log(1111111);
            console.log(this);
        }
    }
    //obj.print();//{a:6,b:7,name: "zhangshang", print: ƒ}
    var fn = obj.print;
    //var fn = obj.print();//undefuned
    //fn(); //this 指向 window // 1111111 window
    obj.print = f1;
    obj.f2(); // this 指向 obj //  {a: 6, b: 7, name: "zhangshang", print: ƒ, f2: ƒ}
    ```

- 构造函数中的this

  -  作为构造函数使用的时候 this指向new关键字创建的实例化对象 

  ```js
  function Student(name,age){
      this.name = name;
      this.age = age;
      console.log(this);
  }
  ```

  - 1. 把构造函数当作普通函数进行调用 那么函数中的this指向window

    ```js
    Student("张三",18); //打印 window
    ```

  -  2. 正常使用 this指向新创建的对象 

    ```js
    var s1 = new Student("张三",18); //打印 Student {name: "张三", age: 18}
    ```

  -  3. 当作为构造函数时 返回值默认是new关键字创建的实例化对象 但是 如果手动添加了返回值 那么 如果是基本数据类型 就不会影响 如果是复杂数据类型 那么就会覆盖掉默认的返回值 

    ```js
    function Student(name,age){
        this.name = name;
        this.age = age;
        console.log(this); //Student {name: "lili", age: 16}
        // return {
        //     name : '111111',
        //     age : 1111111
        // }
        return [12,13,15]
    }
    var s1 = new Student("lili",16);
    console.log(s1); //[12, 13, 15]
    console.log(s1.age); //undefined
    ```

    

## 常见数组方法

**判断是否是数组:**

- isArray()

**添加修改数组：**

- push()
- pop()
- shift()
- unshift()
- slice()
- splice()
- sort()
- reverse()

**是否包含某元素：**

- indexOf()   -1 
- includes()   true

**转换：**

- toString()   // 强转字符串
- join()         // 添加

**数组循环：**

- map()        // 具有返回值,一般使用是在重新需要渲染页面
- forEach()  // 循环
- filter()
- find()      // 返回是一个数组
- findIndex()    // 返回是一个下标
- every()     // 循环每一个,返回true和false
- some()    // 不是全部循环,但凡有一个不满足或者满足就返回
- reduce()  // 进行值的累加和修改  接收的是一个数组
- reduceRight()  // 接收的是一个函数

###  **数组去重**方法

- ##### 双循环去重

  ```js
  function unique(arr) {
      if (!Array.isArray(arr)) {
          console.log('type error!')
          return
      }
      let res = [arr[0]]
      for (let i = 1; i < arr.length; i++) {
          let flag = true
          for (let j = 0; j < res.length; j++) {
              if (arr[i] === res[j]) {
                  flag = false;
                  break
              }
          }
          if (flag) {
              res.push(arr[i])
          }
      }
      return res
  }
  ```

  

- ##### indexOf方法

  -  使用`indexOf()`，可以判断一个数组中是否包含某个值，如果存在则返回该元素在数组中的位置，如果不存在则返回`-1`。 

  ```js
  function unique(arr) {
      if (!Array.isArray(arr)) {
          console.log('type error!')
          return
      }
      let res = []
      for (let i = 0; i < arr.length; i++) {
          if (res.indexOf(arr[i]) === -1) {
              res.push(arr[i])
          }
      }
      return res
  }
  ```

  ```js
  function unique(arr) {
      if (!Array.isArray(arr)) {
          console.log('type error!')
          return
      }
      return Array.prototype.filter.call(arr, function(item, index){
          return arr.indexOf(item) === index;
      });
  }
  ```

- ##### includes()方法

  -  使用`includes()`方法也可以判断数组是否包含某个特定的元素，如果包含就返回`true`不包含就返回`false`。
  - 这和`indexOf()`方法有些类似，所以我们使用`includes()`进行数组去重和`indexOf()`的方法原理是一样的。 

  ```js
  functon unique(arr) {
      let res = []
      for (let i = 0; i < arr.length; i++) {
          if (!res.includes(arr[i])) {
        	    res.push(arr[i])
          }
      }
      return res
  }
  ```

- ##### filter()

  -  `filter()` 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
  - 并且`filter()`**不会改变数组**，也**不会对空数组进行检测**。`filter()`方法接收一个回调函数。 

  ```js
  function unique(arr) {
      return arr.filter((item,index, arr) => {
          return arr.indexOf(item) === index
      })
  }
  console.log(unique(arr)) //[ 1, 'true', 'a', true, false, undefined, null, 'NaN', 0, {}, {}, [], [] ]
  ```

- ##### set()

  ```js
  function unique(arr) {
      if (!Array.isArray(arr)) {
          console.log('type error!')
          return
      }
      return [...new Set(arr)]
  }
  ```

- ##### reduce方法

  ```js
  function unique(arr) {
      return arr.reduce((pre, cur) => {
          !pre.includes(cur) && pre.push(cur)
          return pre
      }, [])
  }
  
  ```

- ##### Array.from

  ```js
  function unique(arr) {
      if (!Array.isArray(arr)) {
          console.log('type error!')
          return
      }
      return Array.from(new Set(arr))
  }
  ```

- ##### 递归去重

  ```js
  let arr = [12,1,12,3,1,88,66,9,66];
  function unique(ary) {
          let  len= ary.length;
          ary = ary.sort(function (a,b) {
              return a-b;
          });
          function loop(index) {
              if(index>=1){
                  if(ary[index]===ary[index-1]){
                      ary.splice(index,1);
                  }
                  loop(index-1)
              }
          }
          loop(len-1);
          return ary;
      }
      console.log(unique(arr));
  ```

- ##### sort() 

  ```js
  function unique(arr) {
      if (!Array.isArray(arr)) {
          console.log('type error!')
          return
      }
      arr = arr.sort()
      let res = []
      for (let i = 0; i < arr.length; i++) {
          if (arr[i] !== arr[i-1]) {
              res.push(arr[i])
          }
      }
      return res
  }
  ```

- ##### Map方法

  - 利用了Map数据结构存值的特点；

    ```js
    let arr = [12,1,12,3,1,88,66,9,66];
    function unique(ary) {
            let newAry =[];
            let map = new Map();
            for(let i=0;i<ary.length;i++){
                if(!map.has(ary[i])){
                    map.set(ary[i],true);
                    newAry.push(ary[i]);
                }
            }
        }
        unique(arr);
    ```



### 基础操作方法

**isArray()**

判断是不是一个数组

```
 let arr = [1,2];
 console.log(Array.isArray(arr)); //true
```

**push()**

向数组***末尾添加***一个或者多个元素，***返回新数组到长度**。**会改变原数组***

```
let arr = [1,2];
let returnValue = arr.push(3,4,5);
console.log(arr); // [1,2,3,4,5]
console.log(returnValue) // 5
```

**pop()**

***删除并返回数组的最后一个元素***，若该数组为空，则返回undefined。***原数组改变。*** ***返回的是被删除的元素***

```
let arr = [1,2,3];
let del = arr.pop();
console.log(arr); // [1,2]
console.log(del); // 3
```

**unshift()**

***向数组的开头添加一个或多个元素，并返回新的数组长度。原数组改变***

```
let arr = [1,2,3];
let returnValue = arr.unshift(4,5);
console.log(arr); // [4,5,1,2,3]
console.log(returnValue) // 5
```

**shift()**

***删除并返回数组的第一个元素，若该数组为空，则返回undefined。原数组改变。***

```
let arr = [1,2,3];
let del = arr.shift();
console.log(del);//1
```

**concat()**

***合并两个或多个数组，生成一个新的数组。原数组不变***

```
let arr = [1,2];
let b = [3,4];
let result = arr.concat(b);
console.log(result) // [1,2,3,4];
```

**reverse()**

***将数组倒序。原数组改变***

```
let arr = [1,2,3,4];
arr.reverse();
console.log(a); // [4,3,2,1]
```

**sort()**

对数组元素进行排序，根据字符串UniCode码排序，原数组改变



```
let arr = [1,2,4,3];
// 升序
arr.sort((a,b)=>{
    return a - b;
});
// 降序
arr.sort((a,b)=>{
    return b - a;
})
```

**原理**

1. **当返回值为负数时，那么前面的数在前面，也就是不动**
2. **当返回值为正数时，那么后面的数在前**
3. **为0，不动**

**join()**

***将数组的每一项用指定字符连接形成一个字符串。默认连接字符为 “,” 逗号。***

```
let arr = [1,2,3,4];
let str = arr.join();
let str1 = arr.join('-');
console.log(str); // 1,2,3,4
console.log(str1); // 1-2-3-4
```

**toString()**

***此方法将数组转化为字符串***

```
let arr = [1, 2, 3, 4, 5];
let str = arr.toString()
console.log(str)// 1,2,3,4,5
```

**slice()**

*slice(start,end).从start开始，end之前结束，不到end。不改变原数组*

```
let a = ['项目一','项目二','项目三']
let arr = a.slice(0,2);
console.log(a); // ["项目一","项目二","项目三"]
console.log(arr); // ["项目一","项目二"]
```

**splice()**

***splice(start, number, item, item) 从start开始删除number位，然后将后面参数插入数组。返回删除元素组成对数组，会改变原数组***

```
let arr = [1,2,3];
let result = arr.splice(1,0,33);
console.log(arr); // [1,33,2,3]
console.log(result); // []
 
```

**indexOf()**

***来查找某个元素的位置，如果不存在就返回-1，但是不能判断是否有NaN的元素***

```
let arr = ['项目一','项目二','项目三'];
let result = arr.indexOf('项目二');
console.log(arr); // 1
```

**includes()**

***判断是否包含某一元素,直接返回true或者false表示是否包含元素，对NaN一样有效。***

```
let arr = ['项目一','项目二','项目三'];
let result = arr.includes('项目一');
console.log(result) // true
```

### 循环方法

**map**

- 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。
- 不改变原数组
- ***返回值是一个新的数组***

```
let testArr = ['子项0','子项1','子项2'];
let resultArr = testArr.map((item, index) => {
  return `处理·${item}`
});
console.log(resultArr);
// 结果： ["处理·子项0", "处理·子项1", "处理·子项2"]
```

**forEach**

- 对数组的每个元素执行一次提供的函数。
- ***总是返回undefined。***
- 不改变原数组

```
let testArr = ['子项0','子项1','子项2'];
testArr.forEach((item, index)=>{
  return `forEach处理${item}`
});
```

**filter**

- 对数组的每一项都进行***过滤***，***返回符合条件的item组成的数组***
- ***不会改变原数组***



```
let filterArr = ['子项0','子项1','子项2'];
let filterResult = filterArr.filter((item, index) => {
  return item === '子项0';
});
console.log(filterArr); // ["子项0", "子项1", "子项2"]
console.log(filterResult);  ["子项0"]
```

**find**

- 遍历数组，找到第一个符合条件的项，并返回该项。否则返回undefined
- 不会改变数组



```
let findArr = ['子项0','子项1','子项2']
let findResult = findArr.find((item, index) => {
  return item === '子项0';
});
console.log(findResult);
// 结果为: 子项0
```

**findIndex**

- ***遍历数组找到第一个符合条件的项，并返回该项的索引值。否则返回-1。***
- ***不会改变数组对象。***



```
let findIndexArr = ['子项0','子项1','子项2'];
let findIndexResult = findIndexArr.findIndex((item, index)=>{
  return item === '子项3';
});
console.log(findIndexResult);
// 结果为： 0
```

**every**

- 对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。***简单说就是看数组的每个元素是否符合要求，都符合则返回true，否则返回false***



```
let everyArr = [2,3,4];
let everyResult = everyArr.every((item, index)=>{
  return item > 0
});
console.log(everyResult);
// 结果为: true
```

**some**

是对数组中每一项运行指定函数，如果该函数对***任一项返回true，则返回true。***

```
let someArr = [2,3,4];
let someResult = someArr.some((item, index)=>{
  return item > 3
});
console.log(someResult);
// 结果为: true
```

**reduce**

- 接收一个函数作为累加器（accumulator），数组中的每个值***（从左到右）***开始缩减，最终为一个值。
- 第二个参数作为第一次调用的a的值

```
// reducer
let reduceArr = [0,1,2,3,4]
let reduceResult = reduceArr.reduce((a, b)=>{
  return a + b;
});
console.log(reduceResult);
// 结果: 10
```

**reduceRight**

- 和reduce一样是累加器，不过是***从右往左计算***
- 第二个参数作为第一次调用的a的值



```
let reduceRightArr = [0,1,2,3,4]
let reduceRightResult = reduceRightArr.reduceRight((a, b)=>{
  return a + b;
});
console.log(reduceRightResult);
// 结果: 10
```

## 跨域

#### 主域名相同，子域名不同会不会产生跨域?

​	**会产生跨域**

**非同源限制:**

- 1.无法读取非同源网页的 Cookie、 Localstorage 和IndexedDB
- 2.无法接触非同源网页的 DOM
- 3.无法向非同源地址发送 Ajax请求通过将二级域名的 cookie 域设置成一级域名，path 设置成”实现共享 cookie

#### 解决方案

```text
跨域的是浏览器自身的一种安全限制策略，只要协议，域名，端口号有一个不一致就会判定为跨域。而 ookie 是有域限制的，所以二级域访问访问顶级域是可以的，而二级域名之间的访问是存在跨域的。所以在做单点登录的时候一般会把 token 存储在一级域名中万二级域名存储自己应用内部本身的数据用于交互。
```

