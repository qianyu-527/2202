<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 继承方法
    //1原型继承
    //构造函数
    // function Super(){this.a=1}
    // Super.prototype.say=function(){console.log('hhh'); }
    // function Sub(){}
    // Sub.prototype=new Super()
    // const test=new Sub()
    // console.log(test.say());

    // function Super(){this.a=1}
    // Super.prototype.say=function(){console.log('hhh'); }
    // function Sub(){}
    // Sub.prototype=new Super()
    // const test=new Sub()
    // console.log(test.say());
    // function Super(){this.a=1}
    // Super.prototype.say=function(){console.log('hhh'); }
    // function Sub(){}
    // Sub.prototype=new Super()
    // const test=new Sub()
    // console.log(test.say());
    //通过原型继承多个引用类型的属性和发方法
    //缺点:Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题
    //盗用构造函数
    //  let Super=function(){this.a=1}
    //  Super.prototype.c=3
    //  function Sub(){
    //     console.log(this,'this');
    //     Super.call(this);
    //     this.b=2;
    //  }
    //  Sub.prototype.d=3
    //  const test= new Sub()
    //  console.log(test,'test');

    //  let Super=function(){this.a=1}
    //  Super.prototype.c=3
    //  function Sub(){
    //     console.log(this,'this');
    //     Super.call(this);
    //     this.b=2;
    //  }
    //  Sub.prototype.d=3
    //  const test= new Sub()
    //  console.log(test,'test');
    //  let Super=function(){this.a=1}
    //  Super.prototype.c=3
    //  function Sub(){
    //     console.log(this,'this');
    //     Super.call(this);
    //     this.b=2;
    //  }
    //  Sub.prototype.d=3
    //  const test= new Sub()
    //  console.log(test,'test');
    //组合继承
    // function Super() {
    //     this.a = [1, 2]
    // }
    // Super.prototype.say = function () {
    //     console.log('hhh');
    // }

    // function Sub() {
    //     Super.call(this)
    //     this.b = 2
    // }
    // Sub.prototype = new Super()
    // const test1 = new Sub()
    // console.log(test1.say()); //hhh
    // test1.a.push(3)
    // console.log(test1.a); //[1,2,3]
    // const text2 = new Sub()
    // console.log(test2.a); //[1,2]

    // function Super() {
    //     this.a = [1, 2]
    // }
    // Super.prototype.say = function () {
    //     console.log('hhh');
    // }

    // function Sub() {
    //     Super.call(this)
    //     this.b = 2
    // }
    // Sub.prototype = new Super()
    // const test1 = new Sub()
    // console.log(test1.say()); //hhh
    // test1.a.push(3)
    // console.log(test1.a); //[1,2,3]
    // const text2 = new Sub()
    // console.log(test2.a); //[1,2]
    // function Super() {
    //     this.a = [1, 2]
    // }
    // Super.prototype.say = function () {
    //     console.log('hhh');
    // }

    // function Sub() {
    //     Super.call(this)
    //     this.b = 2
    // }
    // Sub.prototype = new Super()
    // const test1 = new Sub()
    // console.log(test1.say()); //hhh
    // test1.a.push(3)
    // console.log(test1.a); //[1,2,3]
    // const text2 = new Sub()
    // console.log(test2.a); //[1,2]
  //原型继承
//  ( const obj = { a:[1,2], b:2 }
// const test1 = Object.create(obj)
// const test2 = Object.createobj)

// test1.a.push(3)
// test1.b=3
// console.log(test1.a, test2.a)// [1,2,3]  [1,2,3]
// console.log(test1.b, test2.b)// 3 2

// const obj = { a:[1,2], b:2 }
// const test1 = Object.create(obj)
// const test2 = Object.create(obj)

// test1.a.push(3)
// test1.b=3
// console.log(test1.a, test2.a)// [1,2,3]  [1,2,3]
// console.log(test1.b, test2.b)// 3 2
// const obj = { a:[1,2], b:2 }
// const test1 = Object.create(obj)
// const test2 = Object.create(obj)

// test1.a.push(3)
// test1.b=3
// console.log(test1.a, test2.a)// [1,2,3]  [1,2,3]
// console.log(test1.b, test2.b)// 3 2
    //寄生式继承
//     function createObj(o){
//     let clone = objectCopy(o)
//     clone.say=function(){
//         console.log(‘hhh’)
//     }
//     return clone
// }

// const obj = { a:1 }
// const test = createObj(obj)

// function createObj(o){
//     let clone = objectCopy(o)
//     clone.say=function(){
//         console.log(‘hhh’)
//     }
//     return clone
// }

// const obj = { a:1 }
// const test = createObj(obj)
// function createObj(o){
//     let clone = objectCopy(o)
//     clone.say=function(){
//         console.log(‘hhh’)
//     }
//     return clone
// }

// const obj = { a:1 }
// const test = createObj(obj)
//寄生式组合继承
// function Super(){ this.a=[1,2] }
// Super.prototype.say = function(){ console.log(‘hhh’) }
// function Sub(){
//     Super.call(this)
//     this b=2
// }

// Sub.prototype = Object.create(Super.prototype)
// Sub.prototype.constructor = Sub

// const test = new Sub()

// function Super(){ this.a=[1,2] }
// Super.prototype.say = function(){ console.log(‘hhh’) }
// function Sub(){
//     Super.call(this)
//     this b=2
// }

// Sub.prototype = Object.create(Super.prototype)
// Sub.prototype.constructor = Sub

// const test = new Sub()
// function Super(){ this.a=[1,2] }
// Super.prototype.say = function(){ console.log(‘hhh’) }
// function Sub(){
//     Super.call(this)
//     this b=2
// }

// Sub.prototype = Object.create(Super.prototype)
// Sub.prototype.constructor = Sub

// const test = new Sub()
</script>

</html>